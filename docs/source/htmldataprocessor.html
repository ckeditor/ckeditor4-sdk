<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

( function() {
<span id='CKEDITOR-htmlDataProcessor-method-constructor'><span id='CKEDITOR-htmlDataProcessor'>	/**
</span></span>	 * Represents an HTML data processor, which is responsible for translating and
	 * transforming the editor data on input and output.
	 *
	 * @class
	 * @extends CKEDITOR.dataProcessor
	 * @constructor Creates an htmlDataProcessor class instance.
	 * @param {CKEDITOR.editor} editor
	 */
	CKEDITOR.htmlDataProcessor = function( editor ) {
		var dataFilter, htmlFilter,
			that = this;

		this.editor = editor;

<span id='CKEDITOR-htmlDataProcessor-property-dataFilter'>		/**
</span>		 * Data filter used when processing input by {@link #toHtml}.
		 *
		 * @property {CKEDITOR.htmlParser.filter}
		 */
		this.dataFilter = dataFilter = new CKEDITOR.htmlParser.filter();

<span id='CKEDITOR-htmlDataProcessor-property-htmlFilter'>		/**
</span>		 * HTML filter used when processing output by {@link #toDataFormat}.
		 *
		 * @property {CKEDITOR.htmlParser.filter}
		 */
		this.htmlFilter = htmlFilter = new CKEDITOR.htmlParser.filter();

<span id='CKEDITOR-htmlDataProcessor-property-writer'>		/**
</span>		 * The HTML writer used by this data processor to format the output.
		 *
		 * @property {CKEDITOR.htmlParser.basicWriter}
		 */
		this.writer = new CKEDITOR.htmlParser.basicWriter();

		dataFilter.addRules( defaultDataFilterRulesEditableOnly );
		dataFilter.addRules( defaultDataFilterRulesForAll, { applyToAll: true } );
		dataFilter.addRules( createBogusAndFillerRules( editor, &#39;data&#39; ), { applyToAll: true } );
		htmlFilter.addRules( defaultHtmlFilterRulesEditableOnly );
		htmlFilter.addRules( defaultHtmlFilterRulesForAll, { applyToAll: true } );
		htmlFilter.addRules( createBogusAndFillerRules( editor, &#39;html&#39; ), { applyToAll: true } );

		editor.on( &#39;toHtml&#39;, function( evt ) {
			var evtData = evt.data,
				data = evtData.dataValue;

			// The source data is already HTML, but we need to clean
			// it up and apply the filter.
			data = protectSource( data, editor );

			// Protect content of textareas. (#9995)
			// Do this before protecting attributes to avoid breaking:
			// &lt;textarea&gt;&lt;img src=&quot;...&quot; /&gt;&lt;/textarea&gt;
			data = protectElements( data, protectTextareaRegex );

			// Before anything, we must protect the URL attributes as the
			// browser may changing them when setting the innerHTML later in
			// the code.
			data = protectAttributes( data );

			// Protect elements than can&#39;t be set inside a DIV. E.g. IE removes
			// style tags from innerHTML. (#3710)
			data = protectElements( data, protectElementsRegex );

			// Certain elements has problem to go through DOM operation, protect
			// them by prefixing &#39;cke&#39; namespace. (#3591)
			data = protectElementsNames( data );

			// All none-IE browsers ignore self-closed custom elements,
			// protecting them into open-close. (#3591)
			data = protectSelfClosingElements( data );

			// Compensate one leading line break after &lt;pre&gt; open as browsers
			// eat it up. (#5789)
			data = protectPreFormatted( data );

			// There are attributes which may execute JavaScript code inside fixBin.
			// Encode them greedily. They will be unprotected right after getting HTML from fixBin. (#10)
			data = protectInsecureAttributes( data );

			var fixBin = evtData.context || editor.editable().getName(),
				isPre;

			// Old IEs loose formats when load html into &lt;pre&gt;.
			if ( CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.version &lt; 9 &amp;&amp; fixBin == &#39;pre&#39; ) {
				fixBin = &#39;div&#39;;
				data = &#39;&lt;pre&gt;&#39; + data + &#39;&lt;/pre&gt;&#39;;
				isPre = 1;
			}

			// Call the browser to help us fixing a possibly invalid HTML
			// structure.
			var el = editor.document.createElement( fixBin );
			// Add fake character to workaround IE comments bug. (#3801)
			el.setHtml( &#39;a&#39; + data );
			data = el.getHtml().substr( 1 );

			// Restore shortly protected attribute names.
			data = data.replace( new RegExp( &#39;data-cke-&#39; + CKEDITOR.rnd + &#39;-&#39;, &#39;ig&#39; ), &#39;&#39; );

			isPre &amp;&amp; ( data = data.replace( /^&lt;pre&gt;|&lt;\/pre&gt;$/gi, &#39;&#39; ) );

			// Unprotect &quot;some&quot; of the protected elements at this point.
			data = unprotectElementNames( data );

			data = unprotectElements( data );

			// Restore the comments that have been protected, in this way they
			// can be properly filtered.
			data = unprotectRealComments( data );

			// Now use our parser to make further fixes to the structure, as
			// well as apply the filter.
			evtData.dataValue = CKEDITOR.htmlParser.fragment.fromHtml(
				data, evtData.context, evtData.fixForBody === false ? false : getFixBodyTag( evtData.enterMode, editor.config.autoParagraph ) );
		}, null, null, 5 );

		// Filter incoming &quot;data&quot;.
		// Add element filter before htmlDataProcessor.dataFilter when purifying input data to correct html.
		editor.on( &#39;toHtml&#39;, function( evt ) {
			if ( evt.data.filter.applyTo( evt.data.dataValue, true, evt.data.dontFilter, evt.data.enterMode ) )
				editor.fire( &#39;dataFiltered&#39; );
		}, null, null, 6 );

		editor.on( &#39;toHtml&#39;, function( evt ) {
			evt.data.dataValue.filterChildren( that.dataFilter, true );
		}, null, null, 10 );

		editor.on( &#39;toHtml&#39;, function( evt ) {
			var evtData = evt.data,
				data = evtData.dataValue,
				writer = new CKEDITOR.htmlParser.basicWriter();

			data.writeChildrenHtml( writer );
			data = writer.getHtml( true );

			// Protect the real comments again.
			evtData.dataValue = protectRealComments( data );
		}, null, null, 15 );


		editor.on( &#39;toDataFormat&#39;, function( evt ) {
			var data = evt.data.dataValue;

			// #10854 - we need to strip leading blockless &lt;br&gt; which FF adds
			// automatically when editable contains only non-editable content.
			// We do that for every browser (so it&#39;s a constant behavior) and
			// not in BR mode, in which chance of valid leading blockless &lt;br&gt; is higher.
			if ( evt.data.enterMode != CKEDITOR.ENTER_BR )
				data = data.replace( /^&lt;br *\/?&gt;/i, &#39;&#39; );

			evt.data.dataValue = CKEDITOR.htmlParser.fragment.fromHtml(
				data, evt.data.context, getFixBodyTag( evt.data.enterMode, editor.config.autoParagraph ) );
		}, null, null, 5 );

		editor.on( &#39;toDataFormat&#39;, function( evt ) {
			evt.data.dataValue.filterChildren( that.htmlFilter, true );
		}, null, null, 10 );

		// Transform outcoming &quot;data&quot;.
		// Add element filter after htmlDataProcessor.htmlFilter when preparing output data HTML.
		editor.on( &#39;toDataFormat&#39;, function( evt ) {
			evt.data.filter.applyTo( evt.data.dataValue, false, true );
		}, null, null, 11 );

		editor.on( &#39;toDataFormat&#39;, function( evt ) {
			var data = evt.data.dataValue,
				writer = that.writer;

			writer.reset();
			data.writeChildrenHtml( writer );
			data = writer.getHtml( true );

			// Restore those non-HTML protected source. (#4475,#4880)
			data = unprotectRealComments( data );
			data = unprotectSource( data, editor );

			evt.data.dataValue = data;
		}, null, null, 15 );
	};

	CKEDITOR.htmlDataProcessor.prototype = {
<span id='CKEDITOR-htmlDataProcessor-method-toHtml'>		/**
</span>		 * Processes the input (potentially malformed) HTML to a purified form which
		 * is suitable for using in the WYSIWYG editable.
		 *
		 * This method fires the {@link CKEDITOR.editor#toHtml} event which makes it possible
		 * to hook into the process at various stages.
		 *
		 * **Note:** Since CKEditor 4.3 the signature of this method changed and all options
		 * are now grouped in one `options` object. Previously `context`, `fixForBody` and `dontFilter`
		 * were passed separately.
		 *
		 * @param {String} data The raw data.
		 * @param {Object} [options] The options object.
		 * @param {String} [options.context] The tag name of a context element within which
		 * the input is to be processed, default to be the editable element.
		 * If `null` is passed, then data will be parsed without context (as children of {@link CKEDITOR.htmlParser.fragment}).
		 * See {@link CKEDITOR.htmlParser.fragment#fromHtml} for more details.
		 * @param {Boolean} [options.fixForBody=true] Whether to trigger the auto paragraph for non-block contents.
		 * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},
		 * passed instance will be used to filter the content.
		 * @param {Boolean} [options.dontFilter] Do not filter data with {@link CKEDITOR.filter} (note: transformations
		 * will be still applied).
		 * @param {Number} [options.enterMode] When specified it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.
		 * @returns {String}
		 */
		toHtml: function( data, options, fixForBody, dontFilter ) {
			var editor = this.editor,
				context, filter, enterMode;

			// Typeof null == &#39;object&#39;, so check truthiness of options too.
			if ( options &amp;&amp; typeof options == &#39;object&#39; ) {
				context = options.context;
				fixForBody = options.fixForBody;
				dontFilter = options.dontFilter;
				filter = options.filter;
				enterMode = options.enterMode;
			}
			// Backward compatibility. Since CKEDITOR 4.3 every option was a separate argument.
			else
				context = options;

			// Fall back to the editable as context if not specified.
			if ( !context &amp;&amp; context !== null )
				context = editor.editable().getName();

			return editor.fire( &#39;toHtml&#39;, {
				dataValue: data,
				context: context,
				fixForBody: fixForBody,
				dontFilter: dontFilter,
				filter: filter || editor.filter,
				enterMode: enterMode || editor.enterMode
			} ).dataValue;
		},

<span id='CKEDITOR-htmlDataProcessor-method-toDataFormat'>		/**
</span>		 * See {@link CKEDITOR.dataProcessor#toDataFormat}.
		 *
		 * This method fires the {@link CKEDITOR.editor#toDataFormat} event which makes it possible
		 * to hook into the process at various steps.
		 *
		 * @param {String} html
		 * @param {Object} [options] The options object.
		 * @param {String} [options.context] The tag name of a context element within which
		 * the input is to be processed, default to be the editable element.
		 * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},
		 * passed instance will be used to apply content transformations to the content.
		 * @param {Number} [options.enterMode] When specified it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.
		 * @returns {String}
		 */
		toDataFormat: function( html, options ) {
			var context, filter, enterMode;

			// Do not shorten this to `options &amp;&amp; options.xxx`, because
			// falsy `options` will be passed instead of undefined.
			if ( options ) {
				context = options.context;
				filter = options.filter;
				enterMode = options.enterMode;
			}

			// Fall back to the editable as context if not specified.
			if ( !context &amp;&amp; context !== null )
				context = this.editor.editable().getName();

			return this.editor.fire( &#39;toDataFormat&#39;, {
				dataValue: html,
				filter: filter || this.editor.filter,
				context: context,
				enterMode: enterMode || this.editor.enterMode
			} ).dataValue;
		}
	};

	// Produce a set of filtering rules that handles bogus and filler node at the
	// end of block/pseudo block, in the following consequence:
	// 1. elements:&lt;block&gt; - this filter removes any bogus node, then check
	// if it&#39;s an empty block that requires a filler.
	// 2. elements:&lt;br&gt; - After cleaned with bogus, this filter checks the real
	// line-break BR to compensate a filler after it.
	//
	// Terms definitions:
	// filler: An element that&#39;s either &lt;BR&gt; or &amp;NBSP; at the end of block that established line height.
	// bogus: Whenever a filler is proceeded with inline content, it becomes a bogus which is subjected to be removed.
	//
	// Various forms of the filler:
	// In output HTML: Filler should be consistently &amp;NBSP; &lt;BR&gt; at the end of block is always considered as bogus.
	// In Wysiwyg HTML: Browser dependent - see env.needsBrFiller. Either BR for when needsBrFiller is true, or &amp;NBSP; otherwise.
	// &lt;BR&gt; is NEVER considered as bogus when needsBrFiller is true.
	function createBogusAndFillerRules( editor, type ) {
		function createFiller( isOutput ) {
			return isOutput || CKEDITOR.env.needsNbspFiller ?
				new CKEDITOR.htmlParser.text( &#39;\xa0&#39; ) :
				new CKEDITOR.htmlParser.element( &#39;br&#39;, { &#39;data-cke-bogus&#39;: 1 } );
		}

		// This text block filter, remove any bogus and create the filler on demand.
		function blockFilter( isOutput, fillEmptyBlock ) {

			return function( block ) {

				// DO NOT apply the filer if it&#39;s a fragment node.
				if ( block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )
					return;

				cleanBogus( block );

				// [Opera] it&#39;s mandatory for the filler to present inside of empty block when in WYSIWYG.
				if ( ( ( CKEDITOR.env.opera &amp;&amp; !isOutput ) ||
						( typeof fillEmptyBlock == &#39;function&#39; ? fillEmptyBlock( block ) !== false : fillEmptyBlock ) ) &amp;&amp;
						 isEmptyBlockNeedFiller( block ) )
				{
					block.add( createFiller( isOutput ) );
				}
			};
		}

		// Append a filler right after the last line-break BR, found at the end of block.
		function brFilter( isOutput ) {
			return function( br ) {

				// DO NOT apply the filer if parent&#39;s a fragment node.
				if ( br.parent.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )
					return;

				var attrs = br.attributes;
				// Dismiss BRs that are either bogus or eol marker.
				if ( &#39;data-cke-bogus&#39; in attrs ||
						 &#39;data-cke-eol&#39; in attrs ) {
					delete attrs [ &#39;data-cke-bogus&#39; ];
					return;
				}

				// Judge the tail line-break BR, and to insert bogus after it.
				var next = getNext( br ), previous = getPrevious( br );

				if ( !next &amp;&amp; isBlockBoundary( br.parent ) )
					append( br.parent, createFiller( isOutput ) );
				else if ( isBlockBoundary( next ) &amp;&amp; previous &amp;&amp; !isBlockBoundary( previous ) )
					createFiller( isOutput ).insertBefore( next );
			};
		}

		// Determinate whether this node is potentially a bogus node.
		function maybeBogus( node, atBlockEnd ) {

			// BR that&#39;s not from IE&lt;11 DOM, except for a EOL marker.
			if ( !( isOutput &amp;&amp; !CKEDITOR.env.needsBrFiller ) &amp;&amp;
					 node.type == CKEDITOR.NODE_ELEMENT &amp;&amp; node.name == &#39;br&#39; &amp;&amp;
					 !node.attributes[ &#39;data-cke-eol&#39; ] )
				return true;

			var match;
			// NBSP, possibly.
			if ( node.type == CKEDITOR.NODE_TEXT &amp;&amp;
					 ( match = node.value.match( tailNbspRegex ) ) )
			{
				// We need to separate tail NBSP out of a text node, for later removal.
				if ( match.index ) {
					( new CKEDITOR.htmlParser.text( node.value.substring( 0, match.index ) ) ).insertBefore( node );
					node.value = match[ 0 ];
				}

				// From IE&lt;11 DOM, at the end of a text block, or before block boundary.
				if ( !CKEDITOR.env.needsBrFiller &amp;&amp; isOutput &amp;&amp; ( !atBlockEnd || node.parent.name in textBlockTags ) )
					return true;

				// From the output.
				if ( !isOutput ) {
					var previous = node.previous;

					// Following a line-break at the end of block.
					if ( previous &amp;&amp; previous.name == &#39;br&#39; )
						return true;

					// Or a single NBSP between two blocks.
					if ( !previous || isBlockBoundary( previous ) )
						return true;
				}
			}

			return false;
		}

		// Removes all bogus inside of this block, and to convert fillers into the proper form.
		function cleanBogus( block ) {
			var bogus = [];
			var last = getLast( block ), node, previous;
			if ( last ) {

				// Check for bogus at the end of this block.
				// e.g. &lt;p&gt;foo&lt;br /&gt;&lt;/p&gt;
				maybeBogus( last, 1 ) &amp;&amp; bogus.push( last );

				while ( last ) {

					// Check for bogus at the end of any pseudo block contained.
					if ( isBlockBoundary( last ) &amp;&amp;
							 ( node = getPrevious( last ) ) &amp;&amp;
							 maybeBogus( node ) )
					{
						// Bogus must have inline proceeding, instead single BR between two blocks,
						// is considered as filler, e.g. &lt;hr /&gt;&lt;br /&gt;&lt;hr /&gt;
						if ( ( previous = getPrevious( node ) ) &amp;&amp; !isBlockBoundary( previous ) )
							bogus.push( node );
						// Convert the filler into appropriate form.
						else {
							createFiller( isOutput ).insertAfter( node );
							node.remove();
						}
					}

					last = last.previous;
				}
			}

			// Now remove all bogus collected from above.
			for ( var i = 0 ; i &lt; bogus.length ; i++ )
				bogus[ i ].remove();
		}

		// Judge whether it&#39;s an empty block that requires a filler node.
		function isEmptyBlockNeedFiller( block ) {

			// DO NOT fill empty editable in IE&lt;11.
			if ( !isOutput &amp;&amp; !CKEDITOR.env.needsBrFiller &amp;&amp; block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )
				return false;

			// 1. For IE version &gt;=8,  empty blocks are displayed correctly themself in wysiwiyg;
			// 2. For the rest, at least table cell and list item need no filler space. (#6248)
			if ( !isOutput &amp;&amp; !CKEDITOR.env.needsBrFiller &amp;&amp;
					 ( document.documentMode &gt; 7 ||
						 block.name in CKEDITOR.dtd.tr ||
						 block.name in CKEDITOR.dtd.$listItem ) ) {
				return false;
			}

			var last = getLast( block );
			return !last || block.name == &#39;form&#39; &amp;&amp; last.name == &#39;input&#39; ;
		}

		var rules = { elements: {} };
		var isOutput = type == &#39;html&#39;;

		// Build the list of text blocks.
		var textBlockTags = CKEDITOR.tools.extend( {}, blockLikeTags );
		for ( var i in textBlockTags ) {
			if ( !( &#39;#&#39; in dtd[ i ] ) )
				delete textBlockTags[ i ];
		}

		for ( i in textBlockTags )
			rules.elements[ i ] = blockFilter( isOutput, editor.config.fillEmptyBlocks !== false );

		// Editable element is to be checked separately.
		rules.root = blockFilter( isOutput );
		rules.elements.br = brFilter( isOutput );
		return rules;
	}

	function getFixBodyTag( enterMode, autoParagraph ) {
		return ( enterMode != CKEDITOR.ENTER_BR &amp;&amp; autoParagraph !== false ) ? enterMode == CKEDITOR.ENTER_DIV ? &#39;div&#39; : &#39;p&#39; : false;
	}

	// Regex to scan for &amp;nbsp; at the end of blocks, which are actually placeholders.
	// Safari transforms the &amp;nbsp; to \xa0. (#4172)
	var tailNbspRegex = /(?:&amp;nbsp;|\xa0)$/;

	var protectedSourceMarker = &#39;{cke_protected}&#39;;

	function getLast( node ) {
		var last = node.children[ node.children.length - 1 ];
		while ( last &amp;&amp; isEmpty( last ) )
			last = last.previous;
		return last;
	}

	function getNext( node ) {
		var next = node.next;
		while ( next &amp;&amp; isEmpty( next ) )
			next = next.next;
		return next;
	}

	function getPrevious( node ) {
		var previous = node.previous;
		while ( previous &amp;&amp; isEmpty( previous ) )
			previous = previous.previous;
		return previous;
	}

	// Judge whether the node is an ghost node to be ignored, when traversing.
	function isEmpty( node ) {
		return node.type == CKEDITOR.NODE_TEXT &amp;&amp;
		  !CKEDITOR.tools.trim( node.value ) ||
		  node.type == CKEDITOR.NODE_ELEMENT &amp;&amp;
		  node.attributes[ &#39;data-cke-bookmark&#39; ];
	}

	// Judge whether the node is a block-like element.
	function isBlockBoundary( node ) {
		return node &amp;&amp;
					 ( node.type == CKEDITOR.NODE_ELEMENT &amp;&amp; node.name in blockLikeTags ||
						 node.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT );
	}

	function append( parent, node ) {
		var last = parent.children[ parent.children.length -1 ];
		parent.children.push( node );
		node.parent = parent;
		if ( last ) {
			last.next = node;
			node.previous = last;
		}
	}

	function getNodeIndex( node ) {
		return node.parent ? node.getIndex() : -1;
	}

	var dtd = CKEDITOR.dtd,
		// Define orders of table elements.
		tableOrder = [ &#39;caption&#39;, &#39;colgroup&#39;, &#39;col&#39;, &#39;thead&#39;, &#39;tfoot&#39;, &#39;tbody&#39; ],
		// List of all block elements.
		blockLikeTags = CKEDITOR.tools.extend( {}, dtd.$blockLimit, dtd.$block );

	//
	// DATA filter rules ------------------------------------------------------
	//

	var defaultDataFilterRulesEditableOnly = {
		elements: {
			input: protectReadOnly,
			textarea: protectReadOnly
		}
	};

	// These rules will also be applied to non-editable content.
	var defaultDataFilterRulesForAll = {
		attributeNames: [
			// Event attributes (onXYZ) must not be directly set. They can become
			// active in the editing area (IE|WebKit).
			[ ( /^on/ ), &#39;data-cke-pa-on&#39; ],

			// Don&#39;t let some old expando enter editor. Concerns only IE8,
			// but for consistency remove on all browsers.
			[ ( /^data-cke-expando$/ ), &#39;&#39; ]
		]
	};

	// Disable form elements editing mode provided by some browsers. (#5746)
	function protectReadOnly( element ) {
		var attrs = element.attributes;

		// We should flag that the element was locked by our code so
		// it&#39;ll be editable by the editor functions (#6046).
		if ( attrs.contenteditable != &#39;false&#39; )
			attrs[ &#39;data-cke-editable&#39; ] = attrs.contenteditable ? &#39;true&#39; : 1;

		attrs.contenteditable = &#39;false&#39;;
	}

	//
	// HTML filter rules ------------------------------------------------------
	//

	var defaultHtmlFilterRulesEditableOnly = {
		elements: {
			embed: function( element ) {
				var parent = element.parent;

				// If the &lt;embed&gt; is child of a &lt;object&gt;, copy the width
				// and height attributes from it.
				if ( parent &amp;&amp; parent.name == &#39;object&#39; ) {
					var parentWidth = parent.attributes.width,
						parentHeight = parent.attributes.height;
					if ( parentWidth )
						element.attributes.width = parentWidth;
					if ( parentHeight )
						element.attributes.height = parentHeight;
				}
			},

			// Remove empty link but not empty anchor. (#3829)
			a: function( element ) {
				if ( !( element.children.length || element.attributes.name || element.attributes[ &#39;data-cke-saved-name&#39; ] ) )
					return false;
			}
		}
	};

	// These rules will also be applied to non-editable content.
	var defaultHtmlFilterRulesForAll = {
		elementNames: [
			// Remove the &quot;cke:&quot; namespace prefix.
			[ ( /^cke:/ ), &#39;&#39; ],

			// Ignore &lt;?xml:namespace&gt; tags.
			[ ( /^\?xml:namespace$/ ), &#39;&#39; ]
		],

		attributeNames: [
			// Attributes saved for changes and protected attributes.
			[ ( /^data-cke-(saved|pa)-/ ), &#39;&#39; ],

			// All &quot;data-cke-&quot; attributes are to be ignored.
			[ ( /^data-cke-.*/ ), &#39;&#39; ],

			[ &#39;hidefocus&#39;, &#39;&#39; ]
		],

		elements: {
			$: function( element ) {
				var attribs = element.attributes;

				if ( attribs ) {
					// Elements marked as temporary are to be ignored.
					if ( attribs[ &#39;data-cke-temp&#39; ] )
						return false;

					// Remove duplicated attributes - #3789.
					var attributeNames = [ &#39;name&#39;, &#39;href&#39;, &#39;src&#39; ],
						savedAttributeName;
					for ( var i = 0; i &lt; attributeNames.length; i++ ) {
						savedAttributeName = &#39;data-cke-saved-&#39; + attributeNames[ i ];
						savedAttributeName in attribs &amp;&amp; ( delete attribs[ attributeNames[ i ] ] );
					}
				}

				return element;
			},

			// The contents of table should be in correct order (#4809).
			table: function( element ) {
					// Clone the array as it would become empty during the sort call.
					var children = element.children.slice( 0 );
					children.sort( function( node1, node2 ) {
						var index1, index2;

						// Compare in the predefined order.
						if ( node1.type == CKEDITOR.NODE_ELEMENT &amp;&amp;
								 node2.type == node1.type ) {
							index1 = CKEDITOR.tools.indexOf( tableOrder, node1.name );
							index2 = CKEDITOR.tools.indexOf( tableOrder, node2.name );
						}

						// Make sure the sort is stable, if no order can be established above.
						if ( !( index1 &gt; -1 &amp;&amp; index2 &gt; -1 &amp;&amp; index1 != index2 ) ) {
							index1 = getNodeIndex( node1 );
							index2 = getNodeIndex( node2 );
						}

						return index1 &gt; index2 ? 1 : -1;
					} );
			},

			// Restore param elements into self-closing.
			param: function( param ) {
				param.children = [];
				param.isEmpty = true;
				return param;
			},

			// Remove dummy span in webkit.
			span: function( element ) {
				if ( element.attributes[ &#39;class&#39; ] == &#39;Apple-style-span&#39; )
					delete element.name;
			},

			html: function( element ) {
				delete element.attributes.contenteditable;
				delete element.attributes[ &#39;class&#39; ];
			},

			body: function( element ) {
				delete element.attributes.spellcheck;
				delete element.attributes.contenteditable;
			},

			style: function( element ) {
				var child = element.children[ 0 ];
				if ( child &amp;&amp; child.value )
					child.value = CKEDITOR.tools.trim( child.value );

				if ( !element.attributes.type )
					element.attributes.type = &#39;text/css&#39;;
			},

			title: function( element ) {
				var titleText = element.children[ 0 ];

				// Append text-node to title tag if not present (i.e. non-IEs) (#9882).
				!titleText &amp;&amp; append( element, titleText = new CKEDITOR.htmlParser.text() );

				// Transfer data-saved title to title tag.
				titleText.value = element.attributes[ &#39;data-cke-title&#39; ] || &#39;&#39;;
			},

			input: unprotectReadyOnly,
			textarea: unprotectReadyOnly
		},

		attributes: {
			&#39;class&#39;: function( value, element ) {
				// Remove all class names starting with &quot;cke_&quot;.
				return CKEDITOR.tools.ltrim( value.replace( /(?:^|\s+)cke_[^\s]*/g, &#39;&#39; ) ) || false;
			}
		}
	};

	if ( CKEDITOR.env.ie ) {
		// IE outputs style attribute in capital letters. We should convert
		// them back to lower case, while not hurting the values (#5930)
		defaultHtmlFilterRulesForAll.attributes.style = function( value, element ) {
			return value.replace( /(^|;)([^\:]+)/g, function( match ) {
				return match.toLowerCase();
			} );
		};
	}

	// Disable form elements editing mode provided by some browsers. (#5746)
	function unprotectReadyOnly( element ) {
		var attrs = element.attributes;
		switch ( attrs[ &#39;data-cke-editable&#39; ] ) {
			case &#39;true&#39;:
				attrs.contenteditable = &#39;true&#39;;
				break;
			case &#39;1&#39;:
				delete attrs.contenteditable;
				break;
		}
	}

	//
	// Preprocessor filters ---------------------------------------------------
	//

	var protectElementRegex = /&lt;(a|area|img|input|source)\b([^&gt;]*)&gt;/gi,
		// Be greedy while looking for protected attributes. This will let us avoid an unfortunate
		// situation when &quot;nested attributes&quot;, which may appear valid, are also protected.
		// I.e. if we consider the following HTML:
		//
		// 	&lt;img data-x=&quot;&amp;lt;a href=&amp;quot;X&amp;quot;&quot; /&gt;
		//
		// then the &quot;non-greedy match&quot; returns:
		//
		// 	&#39;href&#39; =&gt; &#39;&amp;quot;X&amp;quot;&#39; // It&#39;s wrong! Href is not an attribute of &lt;img&gt;.
		//
		// while greedy match returns:
		//
		// 	&#39;data-x&#39; =&gt; &#39;&amp;lt;a href=&amp;quot;X&amp;quot;&#39;
		//
		// which, can be easily filtered out (#11508).
		protectAttributeRegex = /([\w-]+)\s*=\s*(?:(?:&quot;[^&quot;]*&quot;)|(?:&#39;[^&#39;]*&#39;)|(?:[^ &quot;&#39;&gt;]+))/gi,
		protectAttributeNameRegex = /^(href|src|name)$/i;

		// Note: we use lazy star &#39;*?&#39; to prevent eating everything up to the last occurrence of &lt;/style&gt; or &lt;/textarea&gt;.
	var protectElementsRegex = /(?:&lt;style(?=[ &gt;])[^&gt;]*&gt;[\s\S]*?&lt;\/style&gt;)|(?:&lt;(:?link|meta|base)[^&gt;]*&gt;)/gi,
		protectTextareaRegex = /(&lt;textarea(?=[ &gt;])[^&gt;]*&gt;)([\s\S]*?)(?:&lt;\/textarea&gt;)/gi,
		encodedElementsRegex = /&lt;cke:encoded&gt;([^&lt;]*)&lt;\/cke:encoded&gt;/gi;

	var protectElementNamesRegex = /(&lt;\/?)((?:object|embed|param|html|body|head|title)[^&gt;]*&gt;)/gi,
		unprotectElementNamesRegex = /(&lt;\/?)cke:((?:html|body|head|title)[^&gt;]*&gt;)/gi;

	var protectSelfClosingRegex = /&lt;cke:(param|embed)([^&gt;]*?)\/?&gt;(?!\s*&lt;\/cke:\1)/gi;

	function protectAttributes( html ) {
		return html.replace( protectElementRegex, function( element, tag, attributes ) {
			return &#39;&lt;&#39; + tag + attributes.replace( protectAttributeRegex, function( fullAttr, attrName ) {
				// Avoid corrupting the inline event attributes (#7243).
				// We should not rewrite the existed protected attributes, e.g. clipboard content from editor. (#5218)
				if ( protectAttributeNameRegex.test( attrName ) &amp;&amp; attributes.indexOf( &#39;data-cke-saved-&#39; + attrName ) == -1 )
					return &#39; data-cke-saved-&#39; + fullAttr + &#39; data-cke-&#39; + CKEDITOR.rnd + &#39;-&#39; + fullAttr;

				return fullAttr;
			} ) + &#39;&gt;&#39;;
		} );
	}

	function protectElements( html, regex ) {
		return html.replace( regex, function( match, tag, content ) {
			// Encode &lt; and &gt; in textarea because this won&#39;t be done by a browser, since
			// textarea will be protected during passing data through fix bin.
			if ( match.indexOf( &#39;&lt;textarea&#39; ) === 0 )
				match = tag + unprotectRealComments( content ).replace( /&lt;/g, &#39;&amp;lt;&#39; ).replace( /&gt;/g, &#39;&amp;gt;&#39; ) + &#39;&lt;/textarea&gt;&#39;;

			return &#39;&lt;cke:encoded&gt;&#39; + encodeURIComponent( match ) + &#39;&lt;/cke:encoded&gt;&#39;;
		} );
	}

	function unprotectElements( html ) {
		return html.replace( encodedElementsRegex, function( match, encoded ) {
			return decodeURIComponent( encoded );
		} );
	}

	function protectElementsNames( html ) {
		return html.replace( protectElementNamesRegex, &#39;$1cke:$2&#39; );
	}

	function unprotectElementNames( html ) {
		return html.replace( unprotectElementNamesRegex, &#39;$1$2&#39; );
	}

	function protectSelfClosingElements( html ) {
		return html.replace( protectSelfClosingRegex, &#39;&lt;cke:$1$2&gt;&lt;/cke:$1&gt;&#39; );
	}

	function protectPreFormatted( html ) {
		return CKEDITOR.env.opera ? html : html.replace( /(&lt;pre\b[^&gt;]*&gt;)(\r\n|\n)/g, &#39;$1$2$2&#39; );
	}

	function protectRealComments( html ) {
		return html.replace( /&lt;!--(?!{cke_protected})[\s\S]+?--&gt;/g, function( match ) {
			return &#39;&lt;!--&#39; + protectedSourceMarker +
				&#39;{C}&#39; +
				encodeURIComponent( match ).replace( /--/g, &#39;%2D%2D&#39; ) +
				&#39;--&gt;&#39;;
		} );
	}

	// Replace all &quot;on\w{3,}&quot; strings which are not:
	// * opening tags - e.g. `&lt;onfoo`,
	// * closing tags - e.g. &lt;/onfoo&gt; (tested in &quot;false positive 1&quot;),
	// * part of other attribute - e.g. `data-onfoo` or `fonfoo`.
	function protectInsecureAttributes( html ) {
		return html.replace( /([^a-z0-9&lt;\-])(on\w{3,})(?!&gt;)/gi, &#39;$1data-cke-&#39; + CKEDITOR.rnd + &#39;-$2&#39; );
	}

	function unprotectRealComments( html ) {
		return html.replace( /&lt;!--\{cke_protected\}\{C\}([\s\S]+?)--&gt;/g, function( match, data ) {
			return decodeURIComponent( data );
		} );
	}

	function unprotectSource( html, editor ) {
		var store = editor._.dataStore;

		return html.replace( /&lt;!--\{cke_protected\}([\s\S]+?)--&gt;/g, function( match, data ) {
			return decodeURIComponent( data );
		} ).replace( /\{cke_protected_(\d+)\}/g, function( match, id ) {
			return store &amp;&amp; store[ id ] || &#39;&#39;;
		} );
	}

	function protectSource( data, editor ) {
		var protectedHtml = [],
			protectRegexes = editor.config.protectedSource,
			store = editor._.dataStore || ( editor._.dataStore = { id: 1 } ),
			tempRegex = /&lt;\!--\{cke_temp(comment)?\}(\d*?)--&gt;/g;

		var regexes = [
			// Script tags will also be forced to be protected, otherwise
			// IE will execute them.
			( /&lt;script[\s\S]*?&lt;\/script&gt;/gi ),

			// &lt;noscript&gt; tags (get lost in IE and messed up in FF).
			/&lt;noscript[\s\S]*?&lt;\/noscript&gt;/gi
		].concat( protectRegexes );

		// First of any other protection, we must protect all comments
		// to avoid loosing them (of course, IE related).
		// Note that we use a different tag for comments, as we need to
		// transform them when applying filters.
		data = data.replace( ( /&lt;!--[\s\S]*?--&gt;/g ), function( match ) {
			return &#39;&lt;!--{cke_tempcomment}&#39; + ( protectedHtml.push( match ) - 1 ) + &#39;--&gt;&#39;;
		} );

		for ( var i = 0; i &lt; regexes.length; i++ ) {
			data = data.replace( regexes[ i ], function( match ) {
				match = match.replace( tempRegex, // There could be protected source inside another one. (#3869).
				function( $, isComment, id ) {
					return protectedHtml[ id ];
				} );

				// Avoid protecting over protected, e.g. /\{.*?\}/
				return ( /cke_temp(comment)?/ ).test( match ) ? match : &#39;&lt;!--{cke_temp}&#39; + ( protectedHtml.push( match ) - 1 ) + &#39;--&gt;&#39;;
			} );
		}
		data = data.replace( tempRegex, function( $, isComment, id ) {
			return &#39;&lt;!--&#39; + protectedSourceMarker +
				( isComment ? &#39;{C}&#39; : &#39;&#39; ) +
				encodeURIComponent( protectedHtml[ id ] ).replace( /--/g, &#39;%2D%2D&#39; ) +
				&#39;--&gt;&#39;;
		} );

		// Different protection pattern is used for those that
		// live in attributes to avoid from being HTML encoded.
		// Why so serious? See #9205, #8216, #7805.
		return data.replace( /&lt;\w([^&#39;&quot;&gt;]+|&#39;[^&#39;]*&#39;|&quot;[^&quot;]*&quot;)+&gt;/g, function( match ) {
			return match.replace( /&lt;!--\{cke_protected\}([^&gt;]*)--&gt;/g, function( match, data ) {
				store[ store.id ] = decodeURIComponent( data );
				return &#39;{cke_protected_&#39; + ( store.id++ ) + &#39;}&#39;;
			} );
		} );
	}
} )();

<span id='CKEDITOR-config-cfg-fillEmptyBlocks'>/**
</span> * Whether a filler text (non-breaking space entity &amp;mdash; `&amp;nbsp;`) will be
 * inserted into empty block elements in HTML output.
 * This is used to render block elements properly with `line-height`.
 * When a function is specified instead, it will be passed a {@link CKEDITOR.htmlParser.element}
 * to decide whether adding the filler text by expecting a Boolean return value.
 *
 *		config.fillEmptyBlocks = false; // Prevent filler nodes in all empty blocks.
 *
 *		// Prevent filler node only in float cleaners.
 *		config.fillEmptyBlocks = function( element ) {
 *			if ( element.attributes[ &#39;class&#39; ].indexOf( &#39;clear-both&#39; ) != -1 )
 *				return false;
 *		};
 *
 * @since 3.5
 * @cfg {Boolean} [fillEmptyBlocks=true]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-editor-event-toHtml'>/**
</span> * This event is fired by the {@link CKEDITOR.htmlDataProcessor} when input HTML
 * is to be purified by the {@link CKEDITOR.htmlDataProcessor#toHtml} method.
 *
 * By adding listeners with different priorities it is possible
 * to process input HTML on different stages:
 *
 *	* 1-4: Data is available in the original string format.
 *	* 5: Data is initially filtered with regexp patterns and parsed to
 *		{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.
 *	* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#dataFilter}
 *		is not applied yet.
 *	* 6: Data is filtered with the {CKEDITOR.filter content filter}.
 *	* 10: Data is processed with {@link CKEDITOR.htmlDataProcessor#dataFilter}.
 *	* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#dataFilter}
 *		has already been applied.
 *	* 15: Data is written back to an HTML string.
 *	* 15-*: Data is available in an HTML string.
 *
 * For example to be able to process parsed, but not yet filtered data add listener this way:
 *
 *		editor.on( &#39;toHtml&#39;, function( evt) {
 *			evt.data.dataValue; // -&gt; CKEDITOR.htmlParser.fragment instance
 *		}, null, null, 7 );
 *
 * @since 4.1
 * @event toHtml
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @param data
 * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Input data to be purified.
 * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toHtml} The `context` argument.
 * @param {Boolean} data.fixForBody See {@link CKEDITOR.htmlDataProcessor#toHtml} The `fixForBody` argument.
 * @param {Boolean} data.dontFilter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `dontFilter` argument.
 * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `filter` argument.
 * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toHtml} The `enterMode` argument.
 */

<span id='CKEDITOR-editor-event-toDataFormat'>/**
</span> * This event is fired when {@link CKEDITOR.htmlDataProcessor} is converting
 * internal HTML to output data HTML.
 *
 * By adding listeners with different priorities it is possible
 * to process input HTML on different stages:
 *
 *	* 1-4: Data is available in the original string format.
 *	* 5: Data is initially filtered with regexp patterns and parsed to
 *		{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.
 *	* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#htmlFilter}
 *		is not applied yet.
 *	* 10: Data is filtered with {@link CKEDITOR.htmlDataProcessor#htmlFilter}.
 *  * 11: Data is filtered with the {CKEDITOR.filter content filter} (on output the content filter makes
 *		only transformations, without filtering).
 *	* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#htmlFilter}
 *		has already been applied.
 *	* 15: Data is written back to an HTML string.
 *	* 15-*: Data is available in an HTML string.
 *
 * For example to be able to process parsed and already processed data add listener this way:
 *
 *		editor.on( &#39;toDataFormat&#39;, function( evt) {
 *			evt.data.dataValue; // -&gt; CKEDITOR.htmlParser.fragment instance
 *		}, null, null, 12 );
 *
 * @since 4.1
 * @event toDataFormat
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @param data
 * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Output data to be prepared.
 * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `context` argument.
 * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `filter` argument.
 * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `enterMode` argument.
 */

</pre>
</body>
</html>
